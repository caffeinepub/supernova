{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Fix auth gating, guest mode UX, and resilient Internet Identity login feedback",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Gate authenticated React Query calls on Internet Identity state to prevent unauthorized backend traps and retries in guest mode.",
      "acceptanceCriteria": [
        "When not logged in, the app does not call backend methods that require user permissions (e.g., getCallerUserProfile, listConversations, getConversationEntries, exportUserData) and does not show uncaught errors due to backend authorization traps.",
        "When logged in, all existing authenticated queries and mutations still work (profile, conversation history, saving entries, export).",
        "React Query does not repeatedly retry unauthorized calls in the background when the user is not authenticated."
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useQueries.ts",
          "operation": "modify",
          "description": "Use the authorization component guidance to ensure authenticated backend calls only run when Internet Identity is present (gate `enabled` for authenticated queries; add `retry: false`/controlled retry behavior for auth-protected queries). Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/hooks/useConversationHistory.ts",
          "operation": "modify",
          "description": "Ensure conversation-history fetching and mutations are only triggered when authenticated, and avoid indirect triggers that could cause authenticated queries to run while unauthenticated (align with auth gating changes). Use authorization component guidance for handling auth-protected data flow; verify the component's usage instructions before implementing."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Add first-class guest UX: allow unlimited chatting without login while clearly labeling Guest and restricting history/export/saving to authenticated sessions without disrupting a guest session on mid-session login.",
      "acceptanceCriteria": [
        "Unauthenticated users can continue sending messages beyond the current limit without being blocked by the composer disabled state.",
        "The UI clearly labels the session as Guest when not authenticated, and indicates which features require login (history sidebar, saving conversation, exporting data).",
        "If a guest user logs in mid-session, the current on-screen chat remains usable (no blank screen / no crash), and the app continues with authenticated features available."
      ],
      "file_operations": [
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Remove the guest message-limit gating that disables the composer; add clear Guest labeling in the header and UI messaging that history/export/saving require login; adjust message hydration logic so a mid-session login does not wipe/replace the current guest chat unless the user explicitly navigates to history. Use authorization component guidance for separating guest vs authenticated feature access; verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/components/history/ConversationSidebar.tsx",
          "operation": "modify",
          "description": "Support a guest-mode sidebar state (or equivalent UI) that explains history/export require login and disables or converts actions into a login prompt while still allowing the main chat UI to function. Verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/hooks/useConversationHistory.ts",
          "operation": "modify",
          "description": "Prevent automatic selection/loading of authenticated conversation history from implicitly overwriting the in-memory guest chat on initial login; only hydrate chat from history on explicit user action (e.g., selecting a conversation/new chat after login). Verify the component's usage instructions before implementing."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Improve login reliability and error reporting in the header login control with actionable recovery and no auth loops.",
      "acceptanceCriteria": [
        "If Internet Identity login fails (including the \"User is already authenticated\" path), the user sees an English error message (toast and/or inline) with a clear next step (e.g., retry login, logout then login).",
        "The login button shows a stable loading state during login and returns to an appropriate idle state afterward.",
        "No infinite login/logout loop occurs when the hook reports \"User is already authenticated\"."
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/auth/LoginButton.tsx",
          "operation": "modify",
          "description": "Add user-facing error reporting (toast and/or inline) for Internet Identity failures; handle \"User is already authenticated\" with a single controlled recovery attempt (e.g., clear then retry once) and provide actionable next steps (retry, logout then login) while maintaining a stable loading state. Use authorization component guidance for clearing cached application data on logout; verify the component's usage instructions before implementing."
        },
        {
          "path": "frontend/src/App.tsx",
          "operation": "modify",
          "description": "Ensure global auth UX messaging aligns with improved login feedback (e.g., guest vs logged-in indicators) and avoids any unintended re-render loops during auth transitions. Verify the component's usage instructions before implementing."
        }
      ]
    }
  ]
}